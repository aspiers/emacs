#!/bin/bash

tty_emacs=fe

# This has to be optional since invocations from mutt must not be
# backgrounded.  It cannot be unconditional (hence the '-if-poss'
# bit) since backgrounding is impossible if we have to fallback
# to tty emacs
if [ "$1" = '--bg-if-poss' ]; then
    bg_if_poss=y
    shift
fi

debug () {
    :
    echo "$*" >&2
}

switch_to_emacsclient () {
    # Save the current winid so we know what to switch back to from emacs.
    client_winid=`current-winid`

    # Switch to emacs window
    switch-to-emacs

    # Wait for editing to be completed
    emacsclient "$@" >/dev/null

    # Switch back to window from which emacsclient was invoked.
    wmctrl -ia $client_winid
}

# If we're on a remote display, don't use emacsclient.
# There must be a better test than this...
if [ -n "$SSH_TTY" ]; then
    "$tty_emacs" "$@"
    exit $?
fi

# Ideally we want to return control to the caller immediately, but at
# the same time wait until emacsclient completes before running
# wmctrl.  But you can't background emacsclient and then re-foreground
# it so it's connected to the tty's STDIN upon fallback to the
# alternative editor, since there's no way of knowing whether the
# fallback occurred until it's too late.  So we need to know in
# advance whether emacsclient will connect to the emacs server, and
# only background if it will:

if emacsclient -e '(emacs-version)' >&/dev/null; then
    # Looks like we found a working server
    if [ -n "$bg_if_poss" ]; then
        switch_to_emacsclient "$@" &
    else
        switch_to_emacsclient "$@"
    fi
else
    # Fallback to tty emacs in foreground
    "$tty_emacs" "$@"
fi
