# Adam's emacs Makefile

# {{{ Determine emacs version

ifndef EMACS
  EMACS=emacs
endif

version=$(shell $(EMACS) --version)

VERSION_NUMBER=$(shell echo "$(version)" | \
                   perl -ne '/^\s*(GNU |X)Emacs (\d+\.\d+)/ && print "$$2"')

# }}}

# {{{ Un-tweakable parameters

MAJOR_MODES = major-modes
MINOR_MODES = minor-modes
UTILS       = utils

# }}}
# {{{ Tweakable parameters

# {{{ global paths

EMACSLIB = $(HOME)/lib/emacs
EMACS_D  = $(HOME)/.emacs.d
INIT_D   = $(EMACS_D)/init.d
LIB_DIR  = $(EMACS_D)/lib
EL_GET   = $(EMACS_D)/el-get

GNUINSTALL_DIR = $(EMACSLIB)/GNU_Emacs

prefix   = $(HOME)/local
infodir = $(prefix)/share/info

# This is where third-party stuff like epg used to get installed,
# although any third-party packages whose Makefiles are flexible
# enough to get installed to $(POST_INSTALL_DIR) should probably
# be installed there for simplicity.
lispdir = $(prefix)/share/emacs/site-lisp

# }}}
# {{{ 3rd party packages

# 3rd party packages are those which have their own Makefiles
# and are responsible for compiling *and* installing themselves.

# Pros of symlinking foo -> foo-1.2.3 approach:
#  - allows different versions per machine
#
# Cons:
#  - need to set up manually?

# This is a list of make targets which have their own Makefiles
# and are responsible for compiling *and* installing themselves.
THIRD_PARTY_PKG_TARGETS =

# Don't automatically compile *.el in or install *.elc from these
# directories:
THIRD_PARTY_PKG_DIRS =

# }}}
# {{{ Where do we pick up .el files which don't have their own Makefiles?

el_search_paths =                       \
        $(wildcard $(MAJOR_MODES)/*.el) \
        $(MINOR_MODES)                  \
        $(UTILS)

# }}}

# {{{ Which .el files should override ones from the emacs distribution?

# N.B. The override is performed by moving these .el files from
# $(POST_INSTALL_DIR) to $(PRE_INSTALL_DIR).

# }}}

# {{{ ignore paths and files

# This will prevent any resulting .elc files from being compiled
# and consequently installed.
NO_COMPILE_EL_PATTERNS =

# This will prevent matching .el files from being installed.
NO_INSTALL_PATTERNS =

# Pretend these don't exist at all.
IGNORE_PATHS =                                          \
        $(MINOR_MODES)/msf-abbrev/mode-abbrevs          \
IGNORE_FILES =                                          \
        loaddefs.el

# }}}
# {{{ Directories to scan for autoload cookies

LOADDEFS_DIRS = $(UTILS) $(LIB_DIR)

# }}}

# }}}

# {{{ Figure out which .els to compile ourselves.

# The list should comprise of everything we can find which we're not
# completely ignoring, but excluding stuff generated by third-party
# Makefiles.

# Horrible horrible horrible.  Prune 3rd party packages from imminent find(1).
PRUNE_DIRS = $(shell echo $(THIRD_PARTY_PKG_DIRS) $(IGNORE_PATHS) | perl -040lpe 's|(.+)|! -path "$$1/*" |g')
PRUNE_FILES = $(shell echo $(THIRD_PARTY_PKG_DIRS) $(IGNORE_FILES) | perl -040lpe 's|(.+)|! -path "$$1" |g')

EL_INSTALLATION_CANDIDATES_cmd =                        \
        find $(el_search_paths)                         \
                -follow                                 \
                -name \*.el                             \
              $(PRUNE_DIRS)                             \
              $(PRUNE_FILES)                            \
              ! -path '*/attic/*'                       \
              ! -path '*/shimbun/*'
EL_INSTALLATION_CANDIDATES = $(shell $(EL_INSTALLATION_CANDIDATES_cmd))

# These are the .elcs we want to build ourselves
ELCs_TO_BE_COMPILED = $(addsuffix c,$(filter-out $(NO_COMPILE_EL_PATTERNS),$(EL_INSTALLATION_CANDIDATES)))

# }}}
# {{{ THIRD_PARTY_ELCs

# Do a separate search for elcs since we want to include ones which were
# built from vendor Makefiles.
# Note that the shell expansion is deferred until needed.
THIRD_PARTY_ELCs = $(shell \
        find $(THIRD_PARTY_PKG_DIRS) -follow -name \*.elc \
)
# We also need to know which vendor-provided .el files to install
# into the destination directory, so that find-library works.
THIRD_PARTY_ELs = $(shell \
        find $(THIRD_PARTY_PKG_DIRS) -follow -name \*.el | so \
)

# }}}

# {{{ Determine compilation variables and parameters

BATCH_EVAL=$(EMACS) -q --batch --no-site-file --eval

SYSTEM_TYPE=$(shell $(BATCH_EVAL) \
                '(message (format "%s" system-type))' 2>&1 | grep -v '^Loading ')

SITE_INSTALL_DIR=$(shell $(BATCH_EVAL) '(princ (car load-path))')

LIBS=as-pre-init-d
LIBDIRS=$(INIT_D)

LOADPATH_OPTS=$(addprefix -L ,$(LIBDIRS))
LOADPATH_OPTS+=$(addprefix -l ,$(LIBS))

# Really ugly hack to add all subdirs of lispdir to the load-path.
# This used to be required so that org-crypt could compile against
# ~/local/share/emacs/site-lisp/epg/
# LOADPATH_OPTS += \
#       --eval "(let ((orig-dir default-directory))             \
#                  (cd \"$(lispdir)\")                          \
#                  (normal-top-level-add-subdirs-to-load-path)  \
#                  (cd orig-dir))"                              \
#       --eval "(normal-top-level-add-to-load-path '(\"$(lispdir)\"))" \
#       --eval "(message (princ-list load-path))"

INSTALL_DIR=$(GNUINSTALL_DIR)/$(VERSION_NUMBER)/$(SYSTEM_TYPE)

PRE_INSTALL_DIR  = $(INSTALL_DIR)/pre
POST_INSTALL_DIR = $(INSTALL_DIR)/post

COMPILER=$(EMACS) --no-site-file
COMPILER += --eval '(setq debug-on-error t)'
#COMPILER_OPTS += --eval '(setq el-get-verbose t)'
COMPILER_BATCH=-batch -f batch-byte-compile
COMPILER_OPTS=$(COMPILER_BATCH)

# }}}

# {{{ Phony targets

# Phony targets are bad except for top-level rules because if a rule A
# has a phony prerequisite B, that phony rule B will always get
# executed, even if B's prerequisites don't need to be, hence the
# parent rule will too.

.PHONY: all #$(THIRD_PARTY_PKG_TARGETS)

# }}}

all: .elcs install

# {{{ debugging targets

show-compiler:
	@echo 'COMPILER:          "$(COMPILER)"'
	@echo 'COMPILER_PRE_OPTS: "$(COMPILER_PRE_OPTS)"'
	@echo 'COMPILER_OPTS:     "$(COMPILER_OPTS)"'

list-libdirs:
	@echo '$(LIBDIRS)'

list-loadpath-opts:
	@echo '$(LOADPATH_OPTS)'

list-prune:
	@echo "$(PRUNE_DIRS)"
	@echo "$(PRUNE_FILES)"

list-el-installation-candidates-cmd:
	@echo "$(EL_INSTALLATION_CANDIDATES_cmd)"

list-el-installation-candidates:
	@for el in $(EL_INSTALLATION_CANDIDATES); do echo $$el; done

list-elcs-to-be-compiled:
	@for elc in $(ELCs_TO_BE_COMPILED); do echo $$elc; done

list-third-party-pkg-dirs:
	@for elc in $(THIRD_PARTY_PKG_DIRS); do echo $$elc; done

list-third-party-els:
	@for elc in $(THIRD_PARTY_ELs); do echo $$elc; done

list-third-party-elcs:
	@for elc in $(THIRD_PARTY_ELCs); do echo $$elc; done

list-install-files:
	@for file in $(INSTALL_FILES); do echo $$file; done

list-install-files-unfiltered:
	@for file in $(INSTALL_FILES_UNFILTERED); do echo $$file; done

# }}}
# {{{ high-level targets

.elcs: $(ELCs_TO_BE_COMPILED) $(THIRD_PARTY_PKG_TARGETS)
	@touch $@

$(PRE_INSTALL_DIR) $(POST_INSTALL_DIR):
	@[ -d $@ ] || mkdir -p $@

.PHONY: install force-install
force-install: clean-installed install

.PHONY: clean-installed
clean-installed:
	@rm -f .installed

install: .installed

# N.B. Must install .el files as well as .elc files so that
# find-function-source-path doesn't need to be extended excessively.
# Note that THIRD_PARTY_ELCs already get installed by third party
# Makefiles into $(lispdir). It would be nice to install the
# THIRD_PARTY_ELs too, although to be soft we would have to install
# them also into $(lispdir) not $(POST_INSTALL_DIR), since e.g. color-theme
# does:
#
# (defcustom color-theme-libraries (directory-files 
#                                   (concat 
#                                    (file-name-directory (locate-library "color-theme"))
#                                    "/themes") t "^color-theme")
INSTALL_FILES_UNFILTERED = \
        $(EL_INSTALLATION_CANDIDATES) $(ELCs_TO_BE_COMPILED)
INSTALL_FILES = $(filter-out $(NO_INSTALL_PATTERNS),$(INSTALL_FILES_UNFILTERED))

ifneq (,$(EL_OVERRIDES))
ALL_OVERRIDES = \
        $(addsuffix .el,  $(EL_OVERRIDES)) \
        $(addsuffix .elc, $(EL_OVERRIDES))
endif

.PHONY: unlock-install-dirs lock-install-dirs
UNLOCK_INSTALL_DIRS = $(MAKE) -s unlock-install-dirs
LOCK_INSTALL_DIRS   = $(MAKE) -s lock-install-dirs
unlock-install-dirs: $(PRE_INSTALL_DIR) $(POST_INSTALL_DIR)
	@echo "Making files in $(PRE_INSTALL_DIR) and $(POST_INSTALL_DIR) read/write ..."
	@chmod -R u+w $(PRE_INSTALL_DIR) $(POST_INSTALL_DIR)
lock-install-dirs:
	@echo "Making files in $(PRE_INSTALL_DIR) and $(POST_INSTALL_DIR) read-only ..."
	@chmod -R a-w $(PRE_INSTALL_DIR) $(POST_INSTALL_DIR)

.installed: .elcs
	@$(UNLOCK_INSTALL_DIRS)
	@echo "Installing .el and .elc files in $(POST_INSTALL_DIR) ..."
	@cp -f $(INSTALL_FILES) $(POST_INSTALL_DIR)
	@cd $(POST_INSTALL_DIR) && \
	   if [ -n "$(ALL_OVERRIDES)" ]; then \
	     echo "Moving overrides from $(POST_INSTALL_DIR) to $(PRE_INSTALL_DIR)" && \
	     mv $(ALL_OVERRIDES) $(PRE_INSTALL_DIR) && \
	     for f in $(ALL_OVERRIDES); do \
	       if [ -e "$$f" ]; then \
	         echo "$$f still in $(POST_INSTALL_DIR) - WHY??"; \
	         exit 1; \
	       fi; \
	     done; \
	   fi
	@$(LOCK_INSTALL_DIRS)
	@touch $@

# Some shitty Solaris makes have broken $(wildcard foo/*.bar)
.PHONY: clean
clean: uninstall $(addprefix clean-, $(TO_CLEAN))
	@-find $(EMACSLIB) -follow -name \*.elc -print | xargs -r rm -f
	rm -f .*-made
	for dir in $(THIRD_PARTY_PKG_DIRS); do \
	        ( cd $$dir && make clean )     \
	done

.PHONY: uninstall
uninstall:
	-find $(PRE_INSTALL_DIR) $(POST_INSTALL_DIR) -name \*.elc -print | \
	        xargs -r rm -f

# }}}
# {{{ Autogenerate loaddefs

# Where to put as-loaddefs.el?  We need it for both compile- and
# run-time, but we don't want to pollute the compile-time load-path
# with POST_INSTALL_DIR, so we put it in a dedicated subdirectory:
LOADDEFS_DIR=$(LIB_DIR)
LOADDEFS=$(LOADDEFS_DIR)/as-loaddefs.el
#LOADDEFS=$(POST_INSTALL_DIR:$(EMACSLIB)/%=%)/as-loaddefs.el

show-loaddefs:
	@echo '$(LOADDEFS)'
LOADDEFS_DEPS_CANDIDATES = $(addsuffix /*.el,$(LOADDEFS_DIRS))
LOADDEFS_DEPS = $(shell grep -l '^;;;\#\#\#autoload' $(LOADDEFS_DEPS_CANDIDATES))
show-loaddefs-deps:
	@echo $(LOADDEFS_DEPS)

# emacs 21 uses update-autoloads-from-directories
# emacs 22 uses update-directory-autoloads
LOADDEFS_DIRS_LISP=$(addsuffix ",$(addprefix ",$(LOADDEFS_DIRS)))
define loaddefs_lisp
(progn \
    (setq generated-autoload-file "$(LOADDEFS)") \
    (if (>= emacs-major-version 22) \
        (update-directory-autoloads $(LOADDEFS_DIRS_LISP)) \
        (update-autoloads-from-directories $(LOADDEFS_DIRS_LISP))))
endef

.PHONY: loaddefs
loaddefs: $(LOADDEFS)

$(LOADDEFS): $(LOADDEFS_DEPS)
	@echo "### Generating $@"
	@$(UNLOCK_INSTALL_DIRS)
	@mkdir -p "$(LOADDEFS_DIR)"
# update-directory-autoloads requires non-empty file to update.
# It also sometimes fails to recognise that the source files have
# relevant changes, so we truncate it every time.
	@echo " " > "$(LOADDEFS)"
	$(BATCH_EVAL) '$(loaddefs_lisp)'
	@$(LOCK_INSTALL_DIRS)

# }}}
# {{{ General pattern-based rules for compiling .el to .elc

# hack to ensure that $(lispdir) exists, but does not force remake
# of targets which depend on it, when its timestamp is updated.
.lispdir:
	@mkdir -p $(lispdir) && touch $@

%.elc: %.el .lispdir
	@if [ -n "$(LIBDIRS)" ]; then \
	  echo "### Compiling $< with libdirs: $(LIBDIRS) ..."; \
	else \
	  echo "### Compiling $< ..."; \
	fi
	@$(COMPILER) $(LOADPATH_OPTS) $(COMPILER_PRE_OPTS) $(COMPILER_OPTS) $<

%.elc.verbose: %.el .lispdir
	@if [ -n "$(LIBDIRS)" ]; then \
	  echo "### Compiling $< with libdirs: $(LIBDIRS) ..."; \
	else \
	  echo "### Compiling $< ..."; \
	fi
	$(COMPILER) $(LOADPATH_OPTS) $(COMPILER_PRE_OPTS) --eval '(setq debug-on-error t)' $(COMPILER_OPTS) $(<:.verbose=)

# The idea behind this one is to launch an emacs in which a manual
# byte-compile of the .el can be debugged, but it doesn't work yet.
%.elc.debug: COMPILER_BATCH='-q -l bytecomp'
%.elc.debug: %.elc
	ln -sf $< $@
#       rm -f $(@:.debug=)
#       $(MAKE) $(@:.debug=) COMPILER_BATCH='-q -l bytecomp'

# }}}
# {{{ Special rules for utils files

# as-gtd needs $(ORG_DIR)/contrib/lisp/org-mairix.el
$(UTILS)/as-gtd.elc $(UTILS)/as-mairix.elc: LIBDIRS += $(UTILS) $(ORG_DIR)/contrib/lisp


# }}}
